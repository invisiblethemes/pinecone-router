{"version":3,"file":"complete.module.js","sources":["../src/route.js","../src/utils.js","../src/index.js"],"sourcesContent":["class Route {\n\tconstructor(path, settings) {\n\t\tthis.path = path;\n\t\tthis.settings = settings;\n\t}\n\n\tsetProps(newProps) {\n\t\tthis.props = newProps;\n\t}\n\n\thandle(context) {\n\t\tif (typeof this.settings.handler == 'function') {\n\t\t\treturn this.settings.handler(context);\n\t\t}\n\t}\n}\n\nexport default Route;\n","var isLocation = !!(window.history.location || window.location);\n\n/**\n * Check if the anchor element point to a navigation route.\n * @param {Element} el The anchor element\n * @param {boolean} hash Set to true when using hash routing\n * @returns {bool} true if the link is valid for navigation, false otherwise\n */\nfunction validLink(el, hash) {\n\t// The checks in this block are taken from page.js https://github.com/visionmedia/page.js/blob/master/index.js#L370\n\t// el.nodeName for svg links are 'a' instead of 'A'\n\twhile (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;\n\tif (!el || 'A' !== el.nodeName.toUpperCase()) return false;\n\n\t// check if link is inside an svg\n\t// in this case, both href and target are always inside an object\n\tvar svg =\n\t\ttypeof el.href === 'object' &&\n\t\tel.href.constructor.name === 'SVGAnimatedString';\n\n\t// Ignore if tag has\n\t// 1. \"download\" attribute\n\t// 2. rel=\"external\" attribute\n\tif (el.hasAttribute('download') || el.getAttribute('rel') === 'external') {\n\t\treturn false;\n\t}\n\n\t// ensure non-hash for the same path\n\tvar link = el.getAttribute('href');\n\tif (!hash && samePath(el) && (el.hash || '#' === link)) {\n\t\treturn;\n\t}\n\n\tvar link = el.getAttribute('href');\n\n\t// Check for mailto: in the href\n\tif (link && link.indexOf('mailto:') > -1) return false;\n\n\t// check target\n\t// svg target is an object and its desired value is in .baseVal property\n\tif (svg ? el.target.baseVal : el.target) return false;\n\n\t// x-origin\n\t// note: svg links that are not relative don't call click events (and skip page.js)\n\t// consequently, all svg links tested inside page.js are relative and in the same origin\n\tif (!svg && !sameOrigin(el.href)) return false;\n\n\treturn true;\n}\n\n/**\n * Process trailing slash in path based on settings\n * @param {string} path the path to be processed\n * @param {boolean} trail null to ignore true to add false to remove\n * @param {string} path path after adding or removing the slash\n */\nexport function processTrailingSlash(path, trail) {\n\tswitch (trail) {\n\t\tcase true:\n\t\t\tif (!path.endsWith('/')) {\n\t\t\t\tpath += '/';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase false:\n\t\t\tif (path.endsWith('/')) {\n\t\t\t\tpath = path.substr(0, path.length - 1);\n\t\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * @param {boolean} hash set to  true when using hash routing\n * @param {object} render render settings\n * @description Add a handler to click events on all links currently in the page\n * if using page or views rendering this will be called everytime the page changes\n * this may also be called by the developer if they added other links dynamicly\n */\nexport function interceptLinks(hash, render = null) {\n\tdocument.querySelectorAll('a').forEach((el) => {\n\t\t// check if we already add this link\n\t\tif (el.hasAttribute('x-link')) return;\n\t\t// check if the link is a navigation link\n\t\tif (validLink(el, hash) == false) return;\n\n\t\t// add an x-link attribute this will tell this function\n\t\t// that the link already been handled.\n\t\tel.setAttribute('x-link', '');\n\n\t\t// X-RENDER ONLY\n\t\tif (render != null) {\n\t\t\tel.addEventListener('mouseover', (e) => {\n\t\t\t\tif (!render.enabled || !render.preload) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet path = e.target.getAttribute('href');\n\t\t\t\tif (path == null) path = '/';\n\t\t\t\tif (render.preloaded.path == path) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\tfetch(path)\n\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\trender.preloaded.path = path;\n\t\t\t\t\t\t\trender.preloaded.content = response;\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// X-RENDER END\n\n\t\tel.addEventListener(\n\t\t\t'click',\n\t\t\t(e) => {\n\t\t\t\te.preventDefault();\n\t\t\t\tlet link = el.pathname;\n\t\t\t\tif (hash) {\n\t\t\t\t\twindow.location.hash = '#' + link;\n\t\t\t\t} else {\n\t\t\t\t\tAlpineRouter.navigate(link);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t});\n}\n\n/**\n * This will replace the content fetched from `path` into `selector`.\n * The content is assumed to not be an entire html page but a chunk of it.\n * @param {string} content the html content.\n * @param {string} selector the selector of where to put the content.\n */\nexport function renderContent(content, selector) {\n\t// replace the content of the selector with the fetched content\n\tdocument.querySelector(selector).innerHTML = content;\n}\n\n/**\n * This will replace the content fetched from `path` into `selector`.\n * Unlike renderContent, this will assume the fetched content to be an entire HTML.\n * meaning it needs to process the routes as well.\n * @param {string} content the html content.\n * @param {string} selector the selector of where to put the content.\n * @param {array} routes routes array to be processed.\n * @returns {array} processed routes\n */\nexport function renderPage(content, selector, routes) {\n\tlet doc = new DOMParser().parseFromString(content, 'text/html');\n\tdoc = doc.querySelector(selector);\n\t// This takes the document fetched, remove routers already initialized from it\n\t// and also remove routers initialized but not found in it\n\t// that is for routers that are not needed in this page.\n\tlet r = processRoutersInFetchedDoc(doc, selector, routes);\n\tdoc = r.doc;\n\tcontent = doc.innerHTML;\n\trenderContent(content, selector);\n\treturn r.routes;\n}\n\nexport function buildContext(route, path, props) {\n\treturn {\n\t\troute: route,\n\t\tpath: path,\n\t\tprops: props,\n\t\tquery: window.location.search.substring(1), // query w/out leading '?'\n\t\thash: window.location.hash.substring(1), // hash without leading '#'\n\t\tgo: (path) => {\n\t\t\twindow.AlpineRouter.navigate(path);\n\t\t\treturn false; // returning false will stop the navigate function, before rendering any views etc.\n\t\t},\n\t};\n}\n\n/**\n * This takes the document fetched, remove routers already initialized from it\n * @param {Document} doc\n * @param {array} routes\n * @returns {object} {doc, routes}\n */\nfunction processRoutersInFetchedDoc(doc, selector, routes) {\n\tlet routersInDoc = doc.querySelectorAll('[x-router]');\n\tswitch (routersInDoc.length) {\n\t\tcase 0:\n\t\t\t// if there is no router in the fetched doc, remove the routes registered\n\t\t\t// but only if the selector is body\n\t\t\tif (selector == 'body') routes = [];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t// the router currently loaded\n\t\t\tlet currentRouter = document.querySelector('[x-router]');\n\t\t\t// if the router in the doc dont have x-router set to 'loaded'\n\t\t\t// thus remove it from the current router element before checking if they're the same\n\t\t\tcurrentRouter.setAttribute('x-router', '');\n\t\t\t// check if the one in fetched doc is the same as the current one\n\t\t\tif (\n\t\t\t\troutersInDoc[0].isEqualNode(\n\t\t\t\t\tdocument.querySelector('[x-router]')\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// if it is, mark the router as loaded, so routes wont be processed again\n\t\t\t\troutersInDoc[0].setAttribute('x-router', 'loaded');\n\t\t\t\t// remove the router element currently in the page, in case it is not within the selector.\n\t\t\t\tdocument.querySelector('[x-router]').remove();\n\t\t\t} else {\n\t\t\t\t// if they're not the same remove the routes, the new ones will be added once this new router is added\n\t\t\t\troutes = [];\n\t\t\t\tdocument.querySelector('[x-router]').remove();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// more than one\n\t\t\tthrow new Error(\n\t\t\t\t'Alpine Router: there can only be one router in the same page'\n\t\t\t);\n\t}\n\n\treturn { doc, routes };\n}\n\n/**\n * Match the path with specified routes\n * Taken from https://github.com/vijitail/simple-javascript-router/blob/master/src/router/Router.js#L14\n * with some modifications to fix bad behavior\n */\nexport function match(route, requestPath) {\n\tlet paramNames = [];\n\tlet path = route.path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\tlet regexPath =\n\t\tpath.replace(/([:^\\s])(\\w+)/g, (_full, _colon, name) => {\n\t\t\tparamNames.push(name);\n\t\t\treturn '([^/]+)';\n\t\t}) + '(?:/|$)';\n\n\tlet params = {};\n\tlet routeMatch = requestPath.match(new RegExp(regexPath));\n\tif (routeMatch !== null) {\n\t\tif (routeMatch.index != 0) return null;\n\t\tif (routeMatch.input != routeMatch[0]) return null;\n\t\tparams = routeMatch.slice(1).reduce((params, value, index) => {\n\t\t\tif (params === null) params = {};\n\t\t\tparams[paramNames[index]] = value;\n\t\t\treturn params;\n\t\t}, null);\n\t}\n\n\troute.setProps(params);\n\treturn routeMatch;\n}\n\n/**\n * Convert to a URL object\n * https://github.com/visionmedia/page.js/blob/4f9991658f9b9e3de9b6059bade93693af24d6bd/page.js#L888\n */\nfunction toURL(href) {\n\tif (typeof URL === 'function' && isLocation) {\n\t\treturn new URL(href, window.location.toString());\n\t} else {\n\t\tvar anc = window.document.createElement('a');\n\t\tanc.href = href;\n\t\treturn anc;\n\t}\n}\n\n/**\n * Check if `href` is the same origin.\n * https://github.com/visionmedia/page.js/blob/4f9991658f9b9e3de9b6059bade93693af24d6bd/page.js#L888\n */\nfunction sameOrigin(href) {\n\tif (!href || !isLocation) return false;\n\n\tvar url = toURL(href);\n\tvar loc = window.location;\n\n\t/*\n\t\t   When the port is the default http port 80 for http, or 443 for\n\t\t   https, internet explorer 11 returns an empty string for loc.port,\n\t\t   so we need to compare loc.port with an empty string if url.port\n\t\t   is the default port 80 or 443.\n\t\t   Also the comparition with `port` is changed from `===` to `==` because\n\t\t   `port` can be a string sometimes. This only applies to ie11.\n\t\t*/\n\treturn (\n\t\tloc.protocol === url.protocol &&\n\t\tloc.hostname === url.hostname &&\n\t\t(loc.port === url.port ||\n\t\t\t(loc.port === '' && (url.port == 80 || url.port == 443)))\n\t); // jshint ignore:line\n}\n\nfunction samePath(url) {\n\tif (!isLocation) return false;\n\tvar loc = window.location;\n\treturn url.pathname === loc.pathname && url.search === loc.search;\n}\n","import Route from './route.js';\nimport {\n\tmatch,\n\tbuildContext,\n\tinterceptLinks,\n\trenderPage,\n\trenderContent,\n\tprocessTrailingSlash,\n} from './utils.js';\n\nconst AlpineRouter = {\n\tversion: '0.0.7',\n\t/**\n\t * @type {array}\n\t * @summary array of routes instantiated from the Route class.\n\t */\n\troutes: [],\n\n\tsettings: {\n\t\t/**\n\t\t * @type {boolean}\n\t\t * @summary detect if links are of the same origin and let Alpine Router handle them\n\t\t */\n\t\tinterceptLinks: true,\n\t\tbasepath: '/',\n\t\ttrailingSlash: null,\n\t\thash: false,\n\t\t/**\n\t\t * @type {boolean}\n\t\t * @summary set to true when using x-render or x-views for they dont need handlers\n\t\t */\n\t\tallowNoHandler: false,\n\t\t/**\n\t\t * @type {boolean}\n\t\t * @summary whether or not to push unregistered paths to history.\n\t\t */\n\t\tpushNotfoundToHistory: true,\n\t\t// X-RENDER ONLY //\n\t\trender: {\n\t\t\tenabled: false,\n\t\t\tselector: 'body',\n\t\t\tpreload: true,\n\t\t\t/**\n\t\t\t * @type {number} miliseconds\n\t\t\t * @summary time to wait after mouse over a link before preloading a page\n\t\t\t */\n\t\t\tpreloadtime: 200,\n\t\t\t/**\n\t\t\t * @type {object}\n\t\t\t * @summary The content that has been preloaded on mouseover event.\n\t\t\t */\n\t\t\tpreloaded: { path: null, content: null }, //\n\t\t},\n\t\t// X-RENDER END\n\n\t\t// X-VIEWS ONLY\n\t\tviews: {\n\t\t\tenabled: false,\n\t\t\tbasepath: '/',\n\t\t\tselector: '#content',\n\t\t\t/**\n\t\t\t * @type {string}\n\t\t\t * @summary the 404 view\n\t\t\t */\n\t\t\tnotfound: null,\n\t\t\t/**\n\t\t\t * @type {bool}\n\t\t\t * @summary views are not dynamically generated, this will cache views for later use.\n\t\t\t */\n\t\t\tstatic: false,\n\t\t\t/**\n\t\t\t * @type {array}\n\t\t\t * @summary array of objects, will hold cached views if static is true\n\t\t\t */\n\t\t\tcached: [],\n\t\t},\n\t\t// X-VIEWS END\n\t},\n\n\t/**\n\t * @type {boolean}\n\t * @summary This will be set to true after all routers are\n\t * initialized and the first page loaded\n\t */\n\tloaded: false,\n\n\t/**\n\t * @type {object}\n\t * @summary The context object for current path.\n\t */\n\tcurrentContext: null,\n\n\t/**\n\t * @event routerloaded\n\t * @summary will be dispatched to window when all routers are\n\t * initialized and the first page loaded\n\t */\n\trouterloaded: new Event('routerloaded'),\n\n\t/**\n\t * @event loadstart\n\t * @summary be dispatched to the window after before page start loading.\n\t */\n\tloadstart: new Event('loadstart'),\n\n\t/**\n\t * @event loadend\n\t * @summary will be dispatched to the window after the page is loaded.\n\t */\n\tloadend: new Event('loadend'),\n\n\t/**\n\t * @description The handler for 404 pages, can be overwritten by a notfound route\n\t// Note that when using x-render or x-views, it'll be set to null in order to let server generate the page\n\t// or user specify the view, respectively.\n\t// Note: if setting routes in the router with x-render you must set notfound route as well\n\t// for example this can be used to validate routes in browser.\n\t * @param {object} context The context object.\n\t */\n\tnotfound: function (context) {\n\t\tconsole.error(\n\t\t\t`Alpine Router: requested path ${context.path} was not found`\n\t\t);\n\t},\n\n\t/**\n\t * Entry point of the plugin\n\t */\n\tstart() {\n\t\tif (!window.Alpine) {\n\t\t\tthrow new Error('Alpine is require for `Alpine Router` to work.');\n\t\t}\n\n\t\t// Routers that are already initialized\n\t\tlet currentRouterCount = 0;\n\n\t\t// Whenever a component is initialized, check if it is a router\n\t\t// and check if the children are valid routes\n\t\tAlpine.onComponentInitialized((component) => {\n\t\t\tif (component.$el.hasAttribute('x-router')) {\n\t\t\t\t// This will check if the router is loaded and return,\n\t\t\t\t// it'll be needed when switching a page\n\t\t\t\t// so the router from that page wont be loaded again if it's the same one\n\t\t\t\tif (component.$el.getAttribute('x-router') == 'loaded') return;\n\n\t\t\t\tif (currentRouterCount > 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Alpine Router: Only one router can be in a page.'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Detect router settings\n\n\t\t\t\t// The router basepath which will be added at the begining\n\t\t\t\t// of every route in this router\n\t\t\t\tif (component.$el.hasAttribute('x-base')) {\n\t\t\t\t\tthis.settings.basepath = component.$el.getAttribute(\n\t\t\t\t\t\t'x-base'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// hash routing\n\t\t\t\tif (component.$el.hasAttribute('x-hash')) {\n\t\t\t\t\tthis.settings.hash = true;\n\t\t\t\t}\n\n\t\t\t\tif (component.$el.hasAttribute('x-slash')) {\n\t\t\t\t\tlet trail = component.$el.getAttribute('x-slash');\n\t\t\t\t\tif (trail == 'add' || trail == '') trail = true;\n\t\t\t\t\telse if (trail == 'remove') trail = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Alpine Router: Invalid value suplied to x-slash must be either \"add\", \"remove\", or empty'\n\t\t\t\t\t\t);\n\t\t\t\t\tthis.settings.trailingSlash = trail;\n\t\t\t\t}\n\n\t\t\t\t// X-RENDER ONLY\n\n\t\t\t\t// page rendering\n\t\t\t\tif (component.$el.hasAttribute('x-render')) {\n\t\t\t\t\tif (this.settings.hash) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Alpine Router: Cannot use x-render along with x-hash.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.settings.render.enabled = true;\n\t\t\t\t\t// check if a selector was set\n\t\t\t\t\tlet selector = component.$el.getAttribute('x-render');\n\t\t\t\t\tif (selector != '') {\n\t\t\t\t\t\tthis.settings.render.selector = selector;\n\t\t\t\t\t}\n\t\t\t\t\t// this will disable notfound handling in favor of server rendered 404 page\n\t\t\t\t\t// this can be ovewritten if needed by making a notfound route with a handler\n\t\t\t\t\tthis.notfound = null;\n\t\t\t\t\tthis.settings.allowNoHandler = true;\n\t\t\t\t}\n\t\t\t\t// X-RENDER END\n\n\t\t\t\t// X-VIEWS ONLY\n\t\t\t\t// views rendering, unlike page rendering.\n\t\t\t\t// they wont be loaded automatically using path\n\t\t\t\t// instead the user decide the view using x-view for each route\n\t\t\t\tif (component.$el.hasAttribute('x-views')) {\n\t\t\t\t\tif (this.settings.render.enabled) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Alpine Router: Cannot use x-views along with x-render.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.settings.views.enabled = true;\n\t\t\t\t\t// check if the selector was set, else default to 'body'\n\t\t\t\t\tlet selector = component.$el.getAttribute('x-views');\n\t\t\t\t\tif (selector == 'body') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Alpine Router: Do not use body as the selector, it will cause the router component to be removed'\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (selector != '') {\n\t\t\t\t\t\tthis.settings.views.selector = selector;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (component.$el.hasAttribute('x-static')) {\n\t\t\t\t\t\tthis.settings.views.static = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// this will disable notfound handling in favor of 404 view\n\t\t\t\t\t// this can be ovewritten if needed by making a notfound route with a handler\n\t\t\t\t\tthis.notfound = null;\n\t\t\t\t\tthis.settings.allowNoHandler = true;\n\t\t\t\t}\n\t\t\t\t// X-VIEWS END\n\n\t\t\t\t// Loop through child elements of this router\n\t\t\t\tArray.from(component.$el.children).forEach((el) => {\n\t\t\t\t\t// if the element is a route process it\n\t\t\t\t\tif (el.hasAttribute('x-route')) {\n\t\t\t\t\t\tthis.processRoute(el, component);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tcomponent.$el.setAttribute('x-router', 'loaded');\n\t\t\t\tcurrentRouterCount++;\n\n\t\t\t\tif (!this.settings.hash) {\n\t\t\t\t\t// navigate to the current page to handle it\n\t\t\t\t\t// ONLY if we not using hash routing for the default router\n\t\t\t\t\tthis.navigate(window.location.pathname, false, true);\n\t\t\t\t} else {\n\t\t\t\t\tif (window.location.hash == '') {\n\t\t\t\t\t\tdocument.location.href =\n\t\t\t\t\t\t\twindow.location.pathname + '#/';\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.navigate(\n\t\t\t\t\t\t\twindow.location.hash.substring(1),\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.loaded = true;\n\t\t\t\twindow.dispatchEvent(this.routerloaded);\n\t\t\t}\n\t\t});\n\n\t\t// Intercept click event in links\n\t\tinterceptLinks(this.settings.hash, this.settings.render);\n\n\t\t// handle navigation events not emitted by links, for exmaple, back button.\n\t\twindow.addEventListener('popstate', () => {\n\t\t\tif (this.settings.hash) {\n\t\t\t\tif (window.location.hash != '') {\n\t\t\t\t\tthis.navigate(window.location.hash.substring(1), true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.navigate(window.location.pathname, true);\n\t\t\t}\n\t\t});\n\n\t\tAlpine.addMagicProperty('router', () => {\n\t\t\treturn window.AlpineRouter.currentContext;\n\t\t});\n\t},\n\n\t/**\n\t * Take the template element of a route and the router component\n\t * @param {Element} el the routes HTML element, must be a template tag.\n\t * @param {object} component the router Alpine component\n\t */\n\tprocessRoute(el, component) {\n\t\tif (el.tagName.toLowerCase() !== 'template') {\n\t\t\tthrow new Error(\n\t\t\t\t'Alpine Router: x-route must be used on a template tag.'\n\t\t\t);\n\t\t}\n\n\t\t// The path will be on x-route and handler on x-handler\n\t\t// The path must be a string and the handler a function callback\n\t\tlet path = el.getAttribute('x-route');\n\t\tif (typeof path != 'string') {\n\t\t\tthrow new Error(\n\t\t\t\t`Alpine Router: x-route must be a string, ${typeof path} given.`\n\t\t\t);\n\t\t}\n\n\t\tif (path.indexOf('#') > -1) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Alpine Router: A route's path may not have a hash, using x-hash is sufficiant.\"\n\t\t\t);\n\t\t}\n\n\t\t// X-VIEWS ONLY\n\t\tlet view = null;\n\t\tif (this.settings.views.enabled) {\n\t\t\tif (el.hasAttribute('x-view') == false) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Alpine Router: route must have an x-view attribute when using x-views.'\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tview = el.getAttribute('x-view');\n\t\t\t\tif (this.settings.views.basepath != '/') {\n\t\t\t\t\tview = this.settings.views.basepath + view;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path == 'notfound') {\n\t\t\t\tthis.settings.views.notfound = view;\n\t\t\t}\n\t\t}\n\t\t// X-VIEWS END\n\n\t\tlet handler = null;\n\t\tif (\n\t\t\tel.hasAttribute('x-handler') == false &&\n\t\t\t!this.settings.allowNoHandler\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'Alpine Router: x-route must have a handler (x-handler=\"handler\") unless using x-views or x-render.'\n\t\t\t);\n\t\t} else if (el.hasAttribute('x-handler')) {\n\t\t\t// Get the hanlder which is a string because it's an attribute value\n\t\t\t// Use that string as an index to the component method which is meant to handle the route\n\t\t\tlet handlerName = el.getAttribute('x-handler');\n\t\t\ttry {\n\t\t\t\thandler = component.getUnobservedData()[handlerName];\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Alpine Router: ' + error);\n\t\t\t}\n\n\t\t\t// Check if the hanlder is a function\n\t\t\tif (typeof handler != 'function') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Alpine Router: handler must be a callback function, ${typeof handler} given.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (path == 'notfound') {\n\t\t\t\t// register the route as a 404 handler\n\t\t\t\tthis.notfound = handler;\n\t\t\t}\n\t\t}\n\n\t\tif (path != 'notfound') {\n\t\t\t// add basepath of the entire page/site\n\t\t\tif (this.settings.basepath != '/' && !this.settings.hash) {\n\t\t\t\tpath = this.settings.basepath + path;\n\t\t\t}\n\n\t\t\tpath = processTrailingSlash(path, this.settings.trailingSlash);\n\n\t\t\t// register the new route if possible\n\n\t\t\t// X-VIEWS ONLY\n\t\t\tif (this.settings.views.enabled) {\n\t\t\t\tthis.addRoute(path, { handler: handler, view: view });\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// X-VIEWS END\n\n\t\t\tthis.addRoute(path, { handler: handler });\n\t\t}\n\t},\n\n\t/**\n\t *  Go to the specified path without reloading\n\t * @param {string} path the path with no hash even if using hash routing\n\t * @param {boolean} frompopstate this will be set to true if called from window.onpopstate event\n\t * @param {boolean} firstload this will be set to true if this is the first page loaded, also from page reload\n\t */\n\tnavigate(path, frompopstate = false, firstload = false) {\n\t\t// process hash route individually\n\t\twindow.dispatchEvent(this.loadstart);\n\n\t\tif (path == null) {\n\t\t\tpath = '/';\n\t\t}\n\n\t\tif (\n\t\t\tthis.settings.basepath != '/' &&\n\t\t\t!this.settings.hash &&\n\t\t\tpath.indexOf(this.settings.basepath) != 0\n\t\t) {\n\t\t\tpath = this.settings.basepath + path;\n\t\t}\n\n\t\tif (path != this.settings.basepath) {\n\t\t\t// add or remove trailing slash based on settings\n\t\t\tpath = processTrailingSlash(path, this.settings.trailingSlash);\n\t\t} else if (!path.endsWith('/')) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tconst route = this.routes.find((route) => {\n\t\t\treturn match(route, path);\n\t\t});\n\n\t\tlet notfound = route == null;\n\t\tlet context;\n\t\tif (notfound) {\n\t\t\tcontext = buildContext('notfound', path, {});\n\t\t\tif (this.notfound != null) {\n\t\t\t\tthis.notfound(context);\n\t\t\t}\n\t\t} else {\n\t\t\tcontext = buildContext(route.path, path, route.props);\n\t\t}\n\n\t\tthis.currentContext = context;\n\n\t\t// the route can be null in case using page or view rendering with no routes\n\t\t// handle routes before rendering to allow checking for permissions etc\n\t\tif (route != null && route.settings.handler != null) {\n\t\t\t// will only be false when using context.go()\n\t\t\tif (route.handle(context) == false) {\n\t\t\t\treturn; // so redirect without finishing\n\t\t\t}\n\t\t}\n\n\t\t// X-RENDER ONLY\n\n\t\t// if using page rendering and the user just (re)loaded the page\n\t\t// dont fetch the content as it is already loaded\n\t\tif (this.settings.render.enabled && !firstload && !notfound) {\n\t\t\tif (this.settings.render.preloaded.path == path) {\n\t\t\t\tthis.routes = renderPage(\n\t\t\t\t\tthis.settings.render.preloaded.content,\n\t\t\t\t\tthis.settings.render.selector,\n\t\t\t\t\tthis.routes\n\t\t\t\t);\n\t\t\t\tinterceptLinks(this.settings.hash, this.settings.render);\n\t\t\t\tthis.settings.render.preloaded.path = null;\n\t\t\t\tthis.settings.render.preloaded.content = null;\n\t\t\t} else {\n\t\t\t\tfetch(path)\n\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t})\n\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\tthis.routes = renderPage(\n\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\tthis.settings.render.selector,\n\t\t\t\t\t\t\tthis.routes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tinterceptLinks(\n\t\t\t\t\t\t\tthis.settings.hash,\n\t\t\t\t\t\t\tthis.settings.render\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// X-RENDER END\n\n\t\t// X-VIEWS ONLY\n\n\t\tlet view =\n\t\t\troute != null ? route.settings.view : this.settings.views.notfound;\n\n\t\tif (this.settings.views.enabled && view != null) {\n\t\t\tif (this.settings.views.static) {\n\t\t\t\t// check if the view was already loaded\n\t\t\t\tvar cachedview = this.settings.views.cached.find(\n\t\t\t\t\t(v) => v.view == view\n\t\t\t\t);\n\t\t\t\tif (cachedview != null) {\n\t\t\t\t\trenderContent(\n\t\t\t\t\t\tcachedview.content,\n\t\t\t\t\t\tthis.settings.views.selector\n\t\t\t\t\t);\n\t\t\t\t\tinterceptLinks(this.settings.hash, this.settings.render);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfetch(view)\n\t\t\t\t.then((response) => {\n\t\t\t\t\treturn response.text();\n\t\t\t\t})\n\t\t\t\t.then((response) => {\n\t\t\t\t\trenderContent(response, this.settings.views.selector);\n\t\t\t\t\tinterceptLinks(this.settings.hash, this.settings.render);\n\t\t\t\t\tif (this.settings.views.static && cachedview == null) {\n\t\t\t\t\t\tthis.settings.views.cached.push({\n\t\t\t\t\t\t\tview: view,\n\t\t\t\t\t\t\tcontent: response,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t\t// X-VIEWS END\n\n\t\t// do not call pushstate from popstate event https://stackoverflow.com/a/50830905\n\t\t// and if the route is not found only push when pushNotfoundToHistory is true\n\t\tif (\n\t\t\t!frompopstate &&\n\t\t\t!(notfound && !this.settings.pushNotfoundToHistory)\n\t\t) {\n\t\t\tlet fullpath = '';\n\n\t\t\tif (this.settings.hash) {\n\t\t\t\tfullpath = '#';\n\t\t\t\tif (window.location.pathname != '/') {\n\t\t\t\t\tfullpath += window.location.pathname;\n\t\t\t\t}\n\t\t\t\tfullpath += window.location.search + path;\n\t\t\t} else {\n\t\t\t\tfullpath = path + window.location.search + window.location.hash;\n\t\t\t}\n\n\t\t\t// handle many routes for different routers\n\t\t\t// but only push the route once to history\n\t\t\thistory.pushState({ path: fullpath }, '', fullpath);\n\t\t}\n\n\t\twindow.dispatchEvent(this.loadend);\n\t},\n\n\t/**\n\t *\n\t * @param {string} path\n\t * @param {function} handler\n\t * @param {string} view can be null\n\t */\n\taddRoute(path, handler, view = null) {\n\t\t// check if the route was registered on the same router.\n\t\tif (this.routes.find((r) => r.path == path) != null) {\n\t\t\tthrow new Error('Alpine Router: route already exist');\n\t\t}\n\n\t\tthis.routes.push(new Route(path, handler, view));\n\t},\n\n\t/**\n\t * Remove a route\n\t * @param {string} path\n\t */\n\tremoveRoute(path) {\n\t\tthis.routes = this.routes.filter((r) => r.path != path);\n\t},\n};\n\nconst alpine = window.deferLoadingAlpine || ((callback) => callback());\n\nwindow.AlpineRouter = AlpineRouter;\n\nwindow.deferLoadingAlpine = function (callback) {\n\twindow.AlpineRouter.start();\n\n\talpine(callback);\n};\n\nexport default AlpineRouter;\n"],"names":["Route","constructor","path","settings","this","setProps","newProps","props","handle","context","handler","isLocation","window","history","location","processTrailingSlash","trail","endsWith","substr","length","interceptLinks","hash","render","document","querySelectorAll","forEach","el","hasAttribute","nodeName","toUpperCase","parentNode","svg","href","name","getAttribute","link","url","loc","pathname","search","samePath","indexOf","target","baseVal","URL","toString","anc","createElement","toURL","protocol","hostname","port","sameOrigin","validLink","setAttribute","addEventListener","e","enabled","preload","preloaded","setTimeout","fetch","then","response","text","content","preventDefault","AlpineRouter","navigate","renderContent","selector","querySelector","innerHTML","renderPage","routes","doc","DOMParser","parseFromString","r","routersInDoc","isEqualNode","remove","Error","processRoutersInFetchedDoc","buildContext","route","query","substring","go","version","basepath","trailingSlash","allowNoHandler","pushNotfoundToHistory","preloadtime","views","notfound","static","cached","loaded","currentContext","routerloaded","Event","loadstart","loadend","console","error","start","Alpine","currentRouterCount","onComponentInitialized","component","$el","Array","from","children","processRoute","dispatchEvent","addMagicProperty","tagName","toLowerCase","view","handlerName","getUnobservedData","addRoute","frompopstate","firstload","find","requestPath","paramNames","regexPath","replace","_full","_colon","push","params","routeMatch","match","RegExp","index","input","slice","reduce","value","cachedview","v","fullpath","pushState","removeRoute","filter","alpine","deferLoadingAlpine","callback"],"mappings":"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"}