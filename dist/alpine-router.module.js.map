{"version":3,"file":"alpine-router.module.js","sources":["../src/route.js","../src/router.js","../src/utils.js","../src/index.js"],"sourcesContent":["class Route {\n\tconstructor(path, handler, router) {\n\t\tthis.path = path;\n\t\tthis.handler = handler;\n\t\tthis.router = router;\n\t}\n\n\tsetProps(newProps) {\n\t\tthis.props = newProps;\n\t}\n\n\thandle() {\n\t\treturn this.handler({props: this.props, path: this.path});\n\t}\n}\n\nexport default Route;","class Router {\n\tconstructor(name, settings) {\n\t\tthis.name = name;\n\t\tthis.settings = settings;\n\t}\n}\n\nexport default Router;","const utils = {\n\tisLocation: !!(window.history.location || window.location),\n\tvalidLink(el) {\n\t\t// The checks in this block are taken from page.js https://github.com/visionmedia/page.js/blob/master/index.js#L370\n\t\t// el.nodeName for svg links are 'a' instead of 'A'\n\t\twhile (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;\n\t\tif (!el || 'A' !== el.nodeName.toUpperCase()) return false;\n\n\t\t// check if link is inside an svg\n\t\t// in this case, both href and target are always inside an object\n\t\tvar svg =\n\t\t\ttypeof el.href === 'object' &&\n\t\t\tel.href.constructor.name === 'SVGAnimatedString';\n\n\t\t// Ignore if tag has\n\t\t// 1. \"download\" attribute\n\t\t// 2. rel=\"external\" attribute\n\t\tif (\n\t\t\tel.hasAttribute('download') ||\n\t\t\tel.getAttribute('rel') === 'external'\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar link = el.getAttribute('href');\n\n\t\t// Check for mailto: in the href\n\t\tif (link && link.indexOf('mailto:') > -1) return false;\n\n\t\t// check target\n\t\t// svg target is an object and its desired value is in .baseVal property\n\t\tif (svg ? el.target.baseVal : el.target) return false;\n\n\t\t// x-origin\n\t\t// note: svg links that are not relative don't call click events (and skip page.js)\n\t\t// consequently, all svg links tested inside page.js are relative and in the same origin\n\t\tif (!svg && !this.sameOrigin(el.href)) return false;\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * This takes the document fetched, remove routers already initialized from it\n\t * @param {Document} doc\n\t * @param {array} routers\n\t * @param {array} routes\n\t * @param {boolean} removeRoutersNotInDoc when true, remove routers initialized but not found in the doc.\n\t * @returns {object} {doc, routers, routes}\n\t */\n\tprocessRoutersInFetchedDoc(\n\t\tdoc,\n\t\trouters,\n\t\troutes,\n\t\tremoveRoutersNotInDoc = true\n\t) {\n\t\t// Name of all routers in the page we fetched\n\t\t// TODO: in docs mention that routers are unique and their\n\t\t// routes cant be changed from page to page when using x-render/x-views\n\t\t// meaning if  'default' router in first page has 6 routes, and 5 in second page\n\t\t// the routes of the second page wont be looked at or read.\n\t\t// instead use a router with a different name, and dont include the default one.\n\n\t\tlet routersInDoc = [];\n\t\tArray.from(doc.querySelectorAll('[x-router]')).forEach((el) => {\n\t\t\tlet name = el.getAttribute('x-router');\n\t\t\tif (name == '') name = 'default';\n\t\t\troutersInDoc.push(name);\n\n\t\t\tif (routers.findIndex((r) => r.name == name) != -1) {\n\t\t\t\t// if there is a router in the fetched page that is already registered\n\t\t\t\t// remove its element\n\t\t\t\tel.remove();\n\t\t\t}\n\t\t});\n\n\t\t// the routes that are not in the page we fetched\n\t\t// meaning they're from another page and are not needed anymore\n\t\tlet routersNotInDoc = routers.filter((r) => {\n\t\t\tlet routerIsInDoc = routersInDoc.findIndex((name) => name == r.name) != -1;\n\t\t\treturn !routerIsInDoc;\n\t\t});\n\n\t\tif (removeRoutersNotInDoc && routersNotInDoc.length > 0) {\n\t\t\t// this will filter out the routers that are not included in the page we fetched\n\t\t\troutes = routes.filter((r) => routersNotInDoc.includes(r.router));\n\t\t\t// this will filter out the routes of the routers that are not included in the page we fetched\n\t\t\trouters = routers.filter((r) => routersNotInDoc.includes(r.name));\n\t\t}\n\n\t\treturn { doc, routers, routes };\n\t},\n\n\t/**\n\t * Match the path with specified routes\n\t * Taken from https://github.com/vijitail/simple-javascript-router/blob/master/src/router/Router.js#L14\n\t * with some modifications to fix bad behavior\n\t */\n\tmatch(route, requestPath) {\n\t\tlet paramNames = [];\n\t\tlet path = route.path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\t\tlet regexPath =\n\t\t\tpath.replace(/([:^\\s])(\\w+)/g, (_full, _colon, name) => {\n\t\t\t\tparamNames.push(name);\n\t\t\t\treturn '([^/]+)';\n\t\t\t}) + '(?:/|$)';\n\n\t\tlet params = {};\n\t\tlet routeMatch = requestPath.match(new RegExp(regexPath));\n\t\tif (routeMatch !== null) {\n\t\t\tif (routeMatch.index != 0) return null;\n\t\t\tif (routeMatch.input != routeMatch[0]) return null;\n\t\t\tparams = routeMatch.slice(1).reduce((params, value, index) => {\n\t\t\t\tif (params === null) params = {};\n\t\t\t\tparams[paramNames[index]] = value;\n\t\t\t\treturn params;\n\t\t\t}, null);\n\t\t}\n\n\t\troute.setProps(params);\n\t\treturn routeMatch;\n\t},\n\n\t/**\n\t * Convert to a URL object\n\t * https://github.com/visionmedia/page.js/blob/4f9991658f9b9e3de9b6059bade93693af24d6bd/page.js#L888\n\t */\n\ttoURL(href) {\n\t\tif (typeof URL === 'function' && this.isLocation) {\n\t\t\treturn new URL(href, window.location.toString());\n\t\t} else {\n\t\t\tvar anc = window.document.createElement('a');\n\t\t\tanc.href = href;\n\t\t\treturn anc;\n\t\t}\n\t},\n\n\t/**\n\t * Check if `href` is the same origin.\n\t * https://github.com/visionmedia/page.js/blob/4f9991658f9b9e3de9b6059bade93693af24d6bd/page.js#L888\n\t */\n\tsameOrigin(href) {\n\t\tif (!href || !this.isLocation) return false;\n\n\t\tvar url = this.toURL(href);\n\t\tvar loc = window.location;\n\n\t\t/*\n\t\t   When the port is the default http port 80 for http, or 443 for\n\t\t   https, internet explorer 11 returns an empty string for loc.port,\n\t\t   so we need to compare loc.port with an empty string if url.port\n\t\t   is the default port 80 or 443.\n\t\t   Also the comparition with `port` is changed from `===` to `==` because\n\t\t   `port` can be a string sometimes. This only applies to ie11.\n\t\t*/\n\t\treturn (\n\t\t\tloc.protocol === url.protocol &&\n\t\t\tloc.hostname === url.hostname &&\n\t\t\t(loc.port === url.port ||\n\t\t\t\t(loc.port === '' && (url.port == 80 || url.port == 443)))\n\t\t); // jshint ignore:line\n\t},\n\n\tsamePath(url) {\n\t\tif (!this.isLocation) return false;\n\t\tvar loc = window.location;\n\t\treturn url.pathname === loc.pathname && url.search === loc.search;\n\t},\n\n\t/**\n\t * Take the router's element and check for settings attribute\n\t */\n\tdetectRouterSettings(el) {\n\t\tlet routerSettings = {};\n\t\t// The router basepath which will be added at the begining\n\t\t// of every route in this router\n\t\tif (el.hasAttribute('x-base')) {\n\t\t\trouterSettings.base = el.getAttribute('x-base');\n\t\t}\n\t\tif (el.hasAttribute('x-render')) {\n\t\t\tlet selector = el.getAttribute('x-render');\n\t\t\trouterSettings.render = selector == '' ? 'body' : selector;\n\t\t}\n\n\t\tif (el.hasAttribute('x-render')) {\n\t\t\trouterSettings.render =\n\t\t\t\tel.getAttribute('x-render') == ''\n\t\t\t\t\t? 'body'\n\t\t\t\t\t: el.getAttribute('x-render');\n\t\t}\n\n\t\treturn routerSettings;\n\t},\n};\n\nexport default utils;\n","import Route from './route.js';\nimport Router from './router.js';\nimport utils from './utils.js';\n\nconst AlpineRouter = {\n\t// routes are instantiated from the Routes classs\n\troutes: [],\n\n\t// array of trings that hold routers name which must be unique.\n\trouters: [],\n\n\t// These can be used to control Alpine Router externally\n\tsettings: {\n\t\tinterceptLinks: true, // detect if links are of the same origin and let Alpine Router handle them\n\t\tbasepath: '/',\n\t\thash: false,\n\t},\n\n\t// This will be set to true after all routers are\n\t// initialized and the first page loaded\n\tloaded: false,\n\n\t// This have the content that has been preloaded on mouseover event.\n\tfetchedContent: { path: null, content: null },\n\n\t// this will be set to true if there is a router that uses view rendering\n\tpreloadPages: false,\n\n\t// The handler for 404 pages, can be overwritten by a custom route\n\tnotfound: function (path) {\n\t\tconsole.error(`Alpine Router: requested path ${path} was not found`);\n\t},\n\n\t// Entry point of the plugin\n\tstart() {\n\t\tif (!window.Alpine) {\n\t\t\tthrow new Error('Alpine is require for `Alpine Router` to work.');\n\t\t}\n\n\t\t// will be dispatched to window when all routers are\n\t\t// initialized and the first page loaded\n\t\tthis.routerloaded = new Event('routerloaded');\n\t\t// will be dispatched before the handler on the responsible router only and the window\n\t\tthis.loadstart = new Event('loadstart');\n\t\t// will be dispatched after the handler is done on the responsible router only and the window\n\t\tthis.loadend = new Event('loadend');\n\n\t\t// Get the amout of routers in the page at load.\n\t\t// However routers may be added dynamically and they will also be initialized.\n\t\tlet routerCount = document.querySelectorAll('[x-data][x-router]')\n\t\t\t.length;\n\n\t\t// Routers that are already initialized\n\t\tlet currentRouterCount = 0;\n\n\t\t// Whenever a component is initialized, check if it is a router\n\t\t// and check if the children are valid routes\n\t\tAlpine.onComponentInitialized((component) => {\n\t\t\tif (component.$el.hasAttribute('x-router')) {\n\t\t\t\t// take the router name if specified\n\t\t\t\tlet routerName = component.$el.getAttribute('x-router');\n\t\t\t\tif (typeof routerName != 'string') {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'Alpine Router: x-router attribute should be a string of the router name or empty for \"default\".'\n\t\t\t\t\t);\n\t\t\t\t\trouterName = 'default';\n\t\t\t\t}\n\n\t\t\t\t// empty x-router will turn to default,\n\t\t\t\t// to easily querySelector() the router later on in this.navigate\n\t\t\t\tif (routerName == '') {\n\t\t\t\t\trouterName = 'default';\n\t\t\t\t\tcomponent.$el.setAttribute('x-router', routerName);\n\t\t\t\t}\n\n\t\t\t\tif (typeof routerName != 'string') {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'Alpine Router: x-router attribute should be a string of the router name or empty for default'\n\t\t\t\t\t);\n\t\t\t\t\trouterName = 'default';\n\t\t\t\t}\n\n\t\t\t\t// A router must have a unique name\n\t\t\t\t// each route will have the name of its router (see this.processRoute() in next lines)\n\t\t\t\tif (this.routers.findIndex((r) => r.name == routerName) > -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Alpine Router: A router with the name ${routerName} already exist. Use a different name by setting the attribute x-router to another value`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Detect other router settings\n\t\t\t\tlet routerSettings = utils.detectRouterSettings(component.$el);\n\t\t\t\t// If using hash routing tell Alpine Router to check for hash everytime it changes\n\t\t\t\t// No need for this as link clicks are handled and pushstate is\n\t\t\t\t// if (this.settings.hash) {\n\t\t\t\t// \twindow.onhashchange = () => {\n\t\t\t\t// \t\t// navigate to the hash route\n\t\t\t\t// \t\tthis.navigate(window.location.hash.substring(1), true);\n\t\t\t\t// \t};\n\t\t\t\t// }\n\n\t\t\t\t// If there is a router that use page rendering then allow preloading on hover\n\t\t\t\tif (!this.preloadPages && routerSettings.render != null) {\n\t\t\t\t\tthis.preloadPages = true;\n\t\t\t\t}\n\n\t\t\t\t// Loop through child elements of this router\n\t\t\t\tArray.from(component.$el.children).forEach((el) => {\n\t\t\t\t\t// if the element is a route process it\n\t\t\t\t\tif (el.hasAttribute('x-route')) {\n\t\t\t\t\t\tthis.processRoute(\n\t\t\t\t\t\t\tel,\n\t\t\t\t\t\t\tcomponent,\n\t\t\t\t\t\t\trouterName,\n\t\t\t\t\t\t\trouterSettings\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Add the router name to the routers array to check for its existance\n\t\t\t\tthis.routers.push(new Router(routerName, routerSettings));\n\n\t\t\t\tcurrentRouterCount++;\n\n\t\t\t\t// this will run when all routers are set up\n\t\t\t\t// in order to handle the current page\n\t\t\t\tif (currentRouterCount == routerCount) {\n\t\t\t\t\tif (!this.settings.hash) {\n\t\t\t\t\t\t// navigate to the current page to handle it\n\t\t\t\t\t\t// ONLY if we not using hash routing for the default router\n\t\t\t\t\t\tthis.navigate(window.location.pathname, false, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (window.location.hash == '') {\n\t\t\t\t\t\t\tdocument.location.href =\n\t\t\t\t\t\t\t\twindow.location.pathname + '#/';\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.navigate(\n\t\t\t\t\t\t\t\twindow.location.hash.substring(1),\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.loaded = true;\n\t\t\t\t\twindow.dispatchEvent(this.routerloaded);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Intercept click event in links\n\t\tthis.interceptLinks();\n\n\t\t// handle navigation events not emitted by links, for exmaple, back button.\n\t\twindow.addEventListener('popstate', () => {\n\t\t\tif (this.settings.hash) {\n\t\t\t\tif (window.location.hash != '') {\n\t\t\t\t\tthis.navigate(window.location.hash.substring(1), true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.navigate(window.location.pathname, true);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Add a handler to click events on all links currently in the page\n\t * if using views rendering this will be called everytime the page changes\n\t * this may also be called by the developer if they added other links dynamicly\n\t */\n\tinterceptLinks() {\n\t\tif (this.settings.interceptLinks) {\n\t\t\tdocument.querySelectorAll('a').forEach((el) => {\n\t\t\t\t// check if we already add this link\n\t\t\t\tif (el.hasAttribute('x-link')) return;\n\t\t\t\t// check if the link is a navigation link\n\t\t\t\tif (utils.validLink(el) == false) return;\n\n\t\t\t\t// add an x-link attribute this will tell this function\n\t\t\t\t// that the link already been handled.\n\t\t\t\tel.setAttribute('x-link', '');\n\n\t\t\t\tel.addEventListener('mouseover', (e) => {\n\t\t\t\t\tif (!this.preloadPages) return;\n\t\t\t\t\tlet path = e.target.getAttribute('href');\n\t\t\t\t\tif (path == null) path = '/';\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.fetchedContent.path != null &&\n\t\t\t\t\t\tthis.fetchedContent.path == path\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t\tfetch(path)\n\t\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\t\twindow.AlpineRouter.fetchedContent.path = path;\n\t\t\t\t\t\t\t\twindow.AlpineRouter.fetchedContent.content = response;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}, this.settings.hoverFetchTime);\n\t\t\t\t});\n\t\t\t\tel.addEventListener(\n\t\t\t\t\t'click',\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tlet link = e.target.getAttribute('href');\n\t\t\t\t\t\tif (this.settings.hash) {\n\t\t\t\t\t\t\twindow.location.hash = '#' + link;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.navigate(link);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\t// TODO: it will cause the links to be handled twice when the page is changed if using x-render\n\t\t// meaning that we need to add x-handled to the link which is too much?\n\t\t// The link validation method from page.js is good i think and this is not needed.\n\t\t// however users can use @click.prevent(AlpineRouter.navigate($el.href))\n\t\t// else {\n\t\t// \t// If we're not intercepting all links, only watch ones with x-link attribute\n\t\t// \tdocument.querySelectorAll('a[x-link]').forEach((el) => {\n\t\t// \t\tel.addEventListener(\n\t\t// \t\t\t'click',\n\t\t// \t\t\t(e) => {\n\t\t// \t\t\t\te.preventDefault();\n\t\t// \t\t\t\tlet link = e.target.getAttribute('href');\n\t\t// \t\t\t\tthis.navigate(link);\n\t\t// \t\t\t},\n\t\t// \t\t\tfalse\n\t\t// \t\t);\n\t\t// \t});\n\t\t// }\n\t},\n\n\t/**\n\t * Take the template element of a route and the router component\n\t * @param {Element} el the routes HTML element, must be a template tag.\n\t * @param {object} component the router Alpine component\n\t * @param {string} routerName the router's name\n\t * @param {object} routerSettings the router's setting object\n\t */\n\tprocessRoute(el, component, routerName, routerSettings) {\n\t\tif (el.tagName.toLowerCase() !== 'template') {\n\t\t\tthrow new Error(\n\t\t\t\t'Alpine Router: x-route must be used on a template tag.'\n\t\t\t);\n\t\t}\n\n\t\t// The path will be on x-route and handler on x-handler\n\t\t// The path must be a string and the handler a function callback\n\t\tlet path = el.getAttribute('x-route');\n\t\tif (typeof path != 'string') {\n\t\t\tthrow new Error(\n\t\t\t\t`Alpine Router: x-route must be a string, ${typeof path} given.`\n\t\t\t);\n\t\t}\n\n\t\tif (path.indexOf('#') > -1) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Alpine Router: A route's path may not have a hash, setting AlpineRouter.settings.hash to true is sufficiant.\"\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tel.hasAttribute('x-handler') == false &&\n\t\t\trouterSettings.render == null\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'Alpine Router: x-route must have a handler (x-handler=\"handler\") unless using x-render.'\n\t\t\t);\n\t\t} else if (el.hasAttribute('x-handler')) {\n\t\t\t// Get the hanlder which is a string because it's an attribute value\n\t\t\t// Use that string as an index to the component method which is meant to handle the route\n\t\t\tlet handlerName = el.getAttribute('x-handler');\n\t\t\tlet handler;\n\t\t\ttry {\n\t\t\t\thandler = component.getUnobservedData()[handlerName];\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Alpine Router: ' + error);\n\t\t\t}\n\n\t\t\t// Check if the hanlder is a function\n\t\t\tif (typeof handler != 'function') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Alpine Router: handler must be a callback function, ${typeof handler} given.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (path == 'notfound') {\n\t\t\t\t// register the route as a 404 handler\n\t\t\t\tthis.notfound = handler;\n\t\t\t}\n\t\t}\n\n\t\tif (path != 'notfound') {\n\t\t\t// add basepath of the entire page/site\n\t\t\tif (['/', '#/'].includes(this.settings.basepath) == false) {\n\t\t\t\tpath = this.settings.basepath + path;\n\t\t\t}\n\n\t\t\t// add basepath of the router\n\t\t\tif (routerSettings.base != null) {\n\t\t\t\tpath = routerSettings.base + path;\n\t\t\t}\n\n\t\t\t// check if the route was registered on the same router.\n\t\t\t// this allow having multiple routers with the same route\n\t\t\t// for example a router for navigation and router for content\n\t\t\tlet routeExist = this.routes\n\t\t\t\t.filter((route) => {\n\t\t\t\t\treturn utils.match(route, path);\n\t\t\t\t})\n\t\t\t\t.forEach((e) => {\n\t\t\t\t\tif (e.router == routerName) return true;\n\t\t\t\t});\n\t\t\tif (routeExist == true) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Alpine Router: Route `${path}` is already registered on router `${routerName}`.'\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// register the new route.\n\t\t\t\tthis.routes.push(new Route(path, handler, routerName));\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t *  Go to the specified path without reloading\n\t * @param {string} path the path with no hash even if using hash routing\n\t * @param {boolean} frompopstate this will be set to true if called from window.onpopstate event\n\t * @param {boolean} firstload this will be set to true if this is the first page loaded, also from page reload\n\t */\n\tnavigate(path, frompopstate = false, firstload = false) {\n\t\t// process hash route individually\n\t\twindow.dispatchEvent(this.loadstart);\n\t\tif (path == null) {\n\t\t\tpath = '/';\n\t\t}\n\t\tconst routes = this.routes.filter((route) => {\n\t\t\treturn utils.match(route, path);\n\t\t});\n\n\t\tif (routes.length == 0) this.notfound(path);\n\n\t\t// do not call pushstate from popstate event https://stackoverflow.com/a/50830905\n\t\tif (!frompopstate) {\n\t\t\tlet fullpath;\n\n\t\t\tif (this.settings.hash) {\n\t\t\t\tfullpath =\n\t\t\t\t\twindow.location.pathname + window.location.search + path;\n\t\t\t} else {\n\t\t\t\tfullpath = path + window.location.search + window.location.hash;\n\t\t\t}\n\t\t\t// handle many routes for different routers\n\t\t\t// but only push the route once to history\n\t\t\thistory.pushState({ path: fullpath }, '', fullpath);\n\t\t}\n\n\t\tlet rendered = false;\n\t\troutes.forEach((route) => {\n\t\t\t// if the user just (re)loaded the page, dont fetch the content for rendering;\n\t\t\tif (firstload != true) {\n\t\t\t\t// If the route is not rendered\n\t\t\t\tif (!rendered) {\n\t\t\t\t\tlet router = this.routers.find(\n\t\t\t\t\t\t(e) => e.name == route.router\n\t\t\t\t\t);\n\t\t\t\t\tif (router.settings.render != null) {\n\t\t\t\t\t\tlet selector = router.settings.render;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.fetchedContent.path != null &&\n\t\t\t\t\t\t\tthis.fetchedContent.path == path\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'Alpine Router: Using preloaded conteent'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.renderEntirePage(\n\t\t\t\t\t\t\t\tthis.fetchedContent.content,\n\t\t\t\t\t\t\t\tselector\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.fetchedContent.path = null;\n\t\t\t\t\t\t\tthis.fetchedContent.content = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfetch(path)\n\t\t\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\t\t\tthis.renderEntirePage(response, selector);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.rendered = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\troute.handle();\n\t\t});\n\t\twindow.dispatchEvent(this.loadend);\n\t},\n\n\t/**\n\t * This will replace the content fetched from `path` into `selector`.\n\t * to use this you need to add x-render to the router\n\t * @param {string} content the html content.\n\t * @param {string} selector the selector of where to put the content.\n\t */\n\trenderEntirePage(content, selector) {\n\t\tlet doc = new DOMParser().parseFromString(content, 'text/html');\n\n\t\tdoc = doc.querySelector(selector);\n\n\t\t// This takes the document fetched, remove routers already initialized from it\n\t\t// and also remove routers initialized but not found in it\n\t\t// that is for routers that are not needed in this page.\n\t\tlet r = utils.processRoutersInFetchedDoc(\n\t\t\tdoc,\n\t\t\tthis.routers,\n\t\t\tthis.routes,\n\t\t\ttrue\n\t\t);\n\n\t\tdoc = r.doc;\n\t\tthis.routers = r.routers;\n\t\tthis.routes = r.routes;\n\n\t\t// check if there is still a router that uses page rendering\n\t\tthis.preloadPages =\n\t\t\tthis.routers.findIndex((e) => e.settings.render != null) != null;\n\n\t\t// replace the content of the selector with the fetched content\n\t\tdocument.querySelector(selector).innerHTML = doc.innerHTML;\n\n\t\tthis.interceptLinks();\n\t},\n\t/**\n\t * This will render content by fetching the path specfied in the routes `x-view`.\n\t * \n\t * @summary To use this add `x-views` to the routers element.\n\t * \n\t * NOTE: This will be called *per route*, not *per path*.\n\t * It means if there were two routers in the page with a route to `/a/path`, meaning two routes,\n\t * the content will be fetched from path in *each route's* `x-view` *two times* and replaces content of `x-selector`\n\t * \n\t * This requires routes to have `x-view` for the *path* of content to fetch, and `x-selector` for *where* to put that content.\n\n\t */\n\trenderChunks() {},\n};\n\nconst alpine = window.deferLoadingAlpine || ((callback) => callback());\n\nwindow.AlpineRouter = AlpineRouter;\n\nwindow.deferLoadingAlpine = function (callback) {\n\twindow.AlpineRouter.start();\n\n\talpine(callback);\n};\n\nexport default AlpineRouter;\n"],"names":["Route","constructor","path","handler","router","this","setProps","newProps","props","handle","Router","name","settings","utils","isLocation","window","history","location","validLink","el","nodeName","toUpperCase","parentNode","svg","href","hasAttribute","getAttribute","link","indexOf","target","baseVal","sameOrigin","processRoutersInFetchedDoc","doc","routers","routes","removeRoutersNotInDoc","routersInDoc","Array","from","querySelectorAll","forEach","push","findIndex","r","remove","routersNotInDoc","filter","length","includes","match","route","requestPath","paramNames","regexPath","replace","_full","_colon","params","routeMatch","RegExp","index","input","slice","reduce","value","toURL","URL","toString","anc","document","createElement","url","loc","protocol","hostname","port","samePath","pathname","search","detectRouterSettings","routerSettings","base","selector","render","AlpineRouter","interceptLinks","basepath","hash","loaded","fetchedContent","content","preloadPages","notfound","console","error","start","Alpine","Error","routerloaded","Event","loadstart","loadend","routerCount","currentRouterCount","onComponentInitialized","component","$el","routerName","warn","setAttribute","children","processRoute","navigate","substring","dispatchEvent","addEventListener","e","setTimeout","fetch","then","response","text","hoverFetchTime","preventDefault","tagName","toLowerCase","handlerName","getUnobservedData","frompopstate","firstload","fullpath","pushState","find","log","renderEntirePage","rendered","DOMParser","parseFromString","querySelector","innerHTML","renderChunks","alpine","deferLoadingAlpine","callback"],"mappings":"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"}